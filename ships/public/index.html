<!doctype html>

<html lang="en">
<head>
    <meta charset="utf-8">

    <title>Ships</title>
    <meta name="description" content="">
    <meta name="author" content="Kevin Albertson">

    <style type="text/css">

        #container {
            width: 1000px;
            margin: 0px auto;
        }
    </style>

    <!--[if lt IE 9]>
    <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>

<body>
    <div id="container">
        <div id='game'></div>
        <div id='debug-controls'></div>
    </div>

    <script src="/client_message.js"></script>
    <script src="/server_response.js"></script>
    <script src='/js/vendor/underscore.js'></script>
    <script src='/js/vendor/pixi.js'></script>
    <script src='/js/particle_emitter.js'></script>
    <script src='/js/client_ship.js'></script>
    <script src='/js/client_cannonball.js'></script>

    <script>
        // Constants.
        var kFixedDelta = 60
            kMaxDelta = 500
            ;

        var playerMap = new Map()
            , playerId = null
            , cannonballs = []
            , ws = new WebSocket('ws://localhost:4080')
            , stage = new PIXI.Container()
            , renderer = PIXI.autoDetectRenderer(1000, 600)
            , serverResponseBuffer = []
            , prevTime = 0
            ;

        ws.addEventListener('message', onServerResponse);

        function tick() {
            var currentTime = Date.now();
            var delta = currentTime - prevTime;
            prevTime = currentTime;
            if (delta > kMaxDelta) {
                window.requestAnimationFrame(tick);
                return;
            }

            // Apply pending updates from server.
            while(serverResponseBuffer.length > 0) {
                applyServerResponse(serverResponseBuffer.shift());
            }

            // Interpolate.
            playerMap.forEach(function(player, id) {
                var ship = player.ship;
                if (ship) {
                    ship.tick(delta);
                    if (ship.isFinishedSinking()) {
                        player.ship = null;
                    }
                    var shipState = ship.getState();
                    var sX = shipState.x, sY = shipState.y;
                    // Check for collisions. TODO: make more efficient using sorting or quad tree.
                    cannonballs.forEach(function(cannonball) {
                        var cannonballState = cannonball.getState();
                        var cX = cannonballState.x, cY = cannonballState.y;
                        if (cannonball.getPlayerId() != id && Math.pow(sX - cX, 2) + Math.pow(sY - cY, 2) <= Math.pow(90, 2)) {
                            ship.handleCollision(cX, cY);
                        }
                    })
                }
            });

            cannonballs.filter(function(cannonball) {
                cannonball.tick(delta);
                return !cannonball.isSunk();
            });

            if (ClientShip.particleEmitter) {
                ClientShip.particleEmitter.tick(delta);
            }

            // Center stage if we have a ship.
            var myPlayer = playerMap.get(playerId);
            var myShip = myPlayer ? myPlayer.ship : null;
            if (myShip) {
                var state = myShip.getState();
                stage.position.set(Math.min(0, renderer.width / 2 - state.x),
                    Math.min(0, renderer.height / 2 - state.y));
            }
            renderer.render(stage);
            window.requestAnimationFrame(tick);
        }
        
        function onServerResponse(raw) {
            let json = ServerResponse.decode(raw.data);
            console.log('Recieved from server', json);
            serverResponseBuffer.push(json);
        }

        // Called at the beginning of the frame.
        function applyServerResponse(json) {
            console.log('Applying', json);
            let id = json.id;
            let player = playerMap.has(id) ? playerMap.get(id) : null;
            let ship = player ? player.ship : null;
            switch (json.type) {
                case ServerResponse.type.kWelcome:
                    play(id);
                    break;
                case ServerResponse.type.kSpawn:
                    if (!player) return;
                    player.ship = new ClientShip(json.data);
                    myShip = player.ship;
                    break;
                case ServerResponse.type.kJoin:
                    if (player) return;
                    playerMap.set(id, json);
                    break;
                case ServerResponse.type.kRefresh:
                    // TODO: clear all ships first?
                    json.data.forEach(function(playerData) {
                        if (playerMap.has(playerData.id)) return;
                        let player = {
                            id: playerData.id
                        };
                        if (playerData.hasOwnProperty('ship')) {
                            player.ship = new ClientShip(playerData.ship, playerData.id);
                        }
                        playerMap.set(playerData.id, player);
                    });
                    break;
                case ServerResponse.type.kShipUpdate:
                    if (!player || !ship) return;
                    ship.applyServerUpdate(json);
                    break;
                case ServerResponse.type.kCannonFire:
                    if (!player || !ship) return;
                    var cannonball = ship.attemptCannonFire();
                    if (cannonball) cannonballs.push(cannonball);
                    break;
                case ServerResponse.type.kBufferedUpdates:
                    json.data.forEach(function(message){
                        applyServerResponse(message);
                    });
                    break;
            }
        }

        function sendJson(json) {
            ws.send(ClientMessage.encode(json));
        }
        
        function play(id) {
            playerId = id;
            sendJson({
                type: ClientMessage.type.kJoin,
                nickname: "kevin" + playerId
            });
        }

        function start() {
            renderer.backgroundColor = 0x4b84f8;
            stage.addChild(new PIXI.extras.TilingSprite(PIXI.loader.resources.water.texture, 10000, 10000));
            document.getElementById('game').appendChild(renderer.view);
            tick();
            container.addEventListener("mousemove", function(e) {
                myShip.handleCollision(e.offsetX, e.offsetY);
            })
        }

        // Preload all resources and start.
        PIXI.loader.add("ship", "img/ship.png")
            .add("cannonball", "img/cannonball.png")
            .add("cannon", "img/cannon.png")
            .add("shipStructure", "img/ship-structure.png")
            .add("water", "img/water.png")
            .load();
        PIXI.loader.once("complete", start);

    </script>

    <script src='/js/debug_controls.js'></script>
</body>
</html>